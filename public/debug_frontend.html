<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰ç«¯è°ƒè¯• - CSVå¤„ç†</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-6xl mx-auto bg-white rounded-lg shadow-lg p-8">
        <h1 class="text-2xl font-bold mb-6">å‰ç«¯è°ƒè¯• - CSVå¤„ç†å®Œæ•´æµç¨‹</h1>
        
        <input type="file" id="csvFile" accept=".csv" class="mb-4">
        <button onclick="debugFile()" class="bg-blue-500 text-white px-4 py-2 rounded mr-2">è°ƒè¯•æ–‡ä»¶å¤„ç†</button>
        <button onclick="testImport()" class="bg-green-500 text-white px-4 py-2 rounded">æµ‹è¯•å¯¼å…¥</button>
        
        <div id="output" class="mt-6 space-y-4"></div>
    </div>

    <script>
        let processedFile = null;
        let processedCSVData = '';
        
        // å®Œå…¨å¤åˆ¶å‰ç«¯çš„é€»è¾‘
        const fieldMapping = {
            'å•†å“åç§°': 'name',
            'å…¬å¸åç§°': 'company_name', 
            'å”®ä»·': 'price',
            'åº“å­˜': 'stock',
            'åˆ†ç±»': 'category',
            'æè¿°': 'description',
            'SKU': 'sku',
            'name': 'name',
            'company_name': 'company_name',
            'price': 'price', 
            'stock': 'stock',
            'category': 'category',
            'description': 'description',
            'sku': 'sku'
        };
        
        function detectEncoding(text) {
            const garbledPatterns = [
                /ï¿½ï¿½/g,
                /ï¿½ï¿½ï¿½/g,
                /Æ·ï¿½ï¿½ï¿½ï¿½/g,
                /ï¿½ï¿½Ë¾ï¿½ï¿½ï¿½ï¿½/g,
                /ï¿½Û¼ï¿½/g,
            ];
            
            const hasGarbledText = garbledPatterns.some(pattern => pattern.test(text));
            const chinesePattern = /[\u4e00-\u9fa5]/g;
            const hasValidChinese = chinesePattern.test(text);
            
            if (hasGarbledText && !hasValidChinese) {
                return 'gbk';
            }
            if (hasGarbledText) {
                return 'gbk';
            }
            return 'utf-8';
        }
        
        async function convertGBKToUTF8(file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch('/api/convert-encoding', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const convertedText = await response.text();
                    const utf8Blob = new Blob([convertedText], { type: 'text/csv;charset=utf-8' });
                    return new File([utf8Blob], file.name, { type: 'text/csv' });
                } else {
                    throw new Error('æœåŠ¡ç«¯è½¬æ¢å¤±è´¥');
                }
            } catch (error) {
                return simpleGBKConvert(file);
            }
        }
        
        async function simpleGBKConvert(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    let text = e.target.result;
                    
                    const gbkMappings = {
                        'ï¿½ï¿½Æ·ï¿½ï¿½ï¿½ï¿½': 'å•†å“åç§°',
                        'ï¿½ï¿½Ë¾ï¿½ï¿½ï¿½ï¿½': 'å…¬å¸åç§°', 
                        'ï¿½Û¼ï¿½': 'å”®ä»·',
                        'ï¿½ï¿½ï¿½': 'åº“å­˜',
                        'ï¿½Å¶ï¿½ï¿½ï¿½ï¿½Ö¿Æ¼ï¿½ï¿½ï¿½ï¿½Ïºï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ş¹ï¿½Ë¾': 'ä¿¡éƒ½æ•°å­—ç§‘æŠ€ï¼ˆä¸Šæµ·ï¼‰æœ‰é™å…¬å¸'
                    };
                    
                    for (const [gbk, utf8] of Object.entries(gbkMappings)) {
                        text = text.replace(new RegExp(gbk, 'g'), utf8);
                    }
                    
                    const utf8Blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
                    resolve(new File([utf8Blob], file.name, { type: 'text/csv' }));
                };
                reader.readAsText(file);
            });
        }
        
        function parseCSV(csvContent) {
            const lines = csvContent.trim().replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            if (lines.length < 2) return [];
            
            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const values = lines[i].split(',');
                const row = {};
                
                headers.forEach((header, index) => {
                    let value = values[index]?.trim() || '';
                    if (value.startsWith('"') && value.endsWith('"')) {
                        value = value.slice(1, -1);
                    }
                    
                    const mappedField = fieldMapping[header] || header;
                    row[mappedField] = value;
                });
                
                data.push(row);
            }
            
            return data;
        }
        
        async function debugFile() {
            const output = document.getElementById('output');
            const fileInput = document.getElementById('csvFile');
            
            if (!fileInput.files[0]) {
                output.innerHTML = '<div class="bg-red-50 p-4 rounded text-red-700">è¯·é€‰æ‹©æ–‡ä»¶</div>';
                return;
            }
            
            const file = fileInput.files[0];
            let logs = [];
            
            try {
                logs.push(`<h3 class="font-bold text-lg">ğŸ“ æ–‡ä»¶ä¿¡æ¯</h3>`);
                logs.push(`æ–‡ä»¶å: ${file.name}`);
                logs.push(`å¤§å°: ${file.size} bytes`);
                logs.push(`ç±»å‹: ${file.type}`);
                
                // æ­¥éª¤1: è¯»å–åŸå§‹æ–‡ä»¶å†…å®¹
                logs.push(`<h3 class="font-bold text-lg mt-4">ğŸ” æ­¥éª¤1: åŸå§‹æ–‡ä»¶è¯»å–</h3>`);
                let csvContent = await file.text();
                logs.push(`åŸå§‹å†…å®¹ï¼ˆå‰100å­—ç¬¦ï¼‰: <code class="bg-gray-100 p-1 rounded">${csvContent.substring(0, 100).replace(/</g, '&lt;')}</code>`);
                
                // æ­¥éª¤2: ç¼–ç æ£€æµ‹
                logs.push(`<h3 class="font-bold text-lg mt-4">ğŸ” æ­¥éª¤2: ç¼–ç æ£€æµ‹</h3>`);
                const encoding = detectEncoding(csvContent);
                logs.push(`æ£€æµ‹åˆ°çš„ç¼–ç : <span class="font-bold text-blue-600">${encoding}</span>`);
                
                // æ­¥éª¤3: ç¼–ç è½¬æ¢
                if (encoding === 'gbk') {
                    logs.push(`<h3 class="font-bold text-lg mt-4">ğŸ”„ æ­¥éª¤3: ç¼–ç è½¬æ¢</h3>`);
                    logs.push(`æ­£åœ¨è½¬æ¢GBKåˆ°UTF-8...`);
                    
                    try {
                        processedFile = await convertGBKToUTF8(file);
                        csvContent = await processedFile.text();
                        logs.push(`è½¬æ¢åå†…å®¹ï¼ˆå‰100å­—ç¬¦ï¼‰: <code class="bg-gray-100 p-1 rounded">${csvContent.substring(0, 100)}</code>`);
                        logs.push(`<span class="text-green-600">âœ… ç¼–ç è½¬æ¢æˆåŠŸ</span>`);
                    } catch (error) {
                        logs.push(`<span class="text-red-600">âŒ ç¼–ç è½¬æ¢å¤±è´¥: ${error.message}</span>`);
                    }
                } else {
                    logs.push(`<h3 class="font-bold text-lg mt-4">âœ… æ­¥éª¤3: æ— éœ€ç¼–ç è½¬æ¢</h3>`);
                    processedFile = file;
                }
                
                processedCSVData = csvContent;
                
                // æ­¥éª¤4: CSVè§£æ
                logs.push(`<h3 class="font-bold text-lg mt-4">ğŸ“‹ æ­¥éª¤4: CSVè§£æ</h3>`);
                const parsedData = parseCSV(csvContent);
                logs.push(`è§£æè¡Œæ•°: ${parsedData.length}`);
                
                if (parsedData.length > 0) {
                    const firstRow = parsedData[0];
                    const fields = Object.keys(firstRow);
                    logs.push(`ç¬¬ä¸€è¡Œå­—æ®µ: <code class="bg-gray-100 p-1 rounded">${fields.join(', ')}</code>`);
                    
                    const requiredFields = ['name', 'company_name', 'price', 'stock'];
                    const missingFields = requiredFields.filter(field => !fields.includes(field));
                    
                    if (missingFields.length === 0) {
                        logs.push(`<span class="text-green-600">âœ… æ‰€æœ‰å¿…è¦å­—æ®µå®Œæ•´</span>`);
                    } else {
                        logs.push(`<span class="text-red-600">âŒ ç¼ºå°‘å¿…è¦å­—æ®µ: ${missingFields.join(', ')}</span>`);
                    }
                    
                    logs.push(`ç¬¬ä¸€è¡Œæ•°æ®é¢„è§ˆ:`);
                    logs.push(`<pre class="bg-gray-100 p-3 rounded text-sm">${JSON.stringify(firstRow, null, 2)}</pre>`);
                }
                
            } catch (error) {
                logs.push(`<span class="text-red-600">âŒ å¤„ç†å¤±è´¥: ${error.message}</span>`);
            }
            
            output.innerHTML = `<div class="bg-blue-50 border border-blue-200 rounded p-4">
                ${logs.map(log => `<p class="mb-2">${log}</p>`).join('')}
            </div>`;
        }
        
        async function testImport() {
            const output = document.getElementById('output');
            
            if (!processedCSVData) {
                output.innerHTML += '<div class="bg-yellow-50 p-4 rounded text-yellow-700 mt-4">è¯·å…ˆè°ƒè¯•æ–‡ä»¶å¤„ç†</div>';
                return;
            }
            
            try {
                // ç™»å½•
                const loginResponse = await fetch('/api/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: 'admin', password: 'admin' })
                });
                
                const loginData = await loginResponse.json();
                if (!loginData.success) {
                    throw new Error('ç™»å½•å¤±è´¥');
                }
                
                // æµ‹è¯•å¯¼å…¥ï¼ˆåªå–å‰3è¡Œï¼‰
                const testData = processedCSVData.split('\n').slice(0, 4).join('\n');
                
                const importResponse = await fetch('/api/products/import-csv', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${loginData.data.token}`
                    },
                    body: JSON.stringify({ csvData: testData })
                });
                
                const importResult = await importResponse.json();
                
                let result = `<h3 class="font-bold text-lg mt-4">ğŸš€ å¯¼å…¥æµ‹è¯•ç»“æœ</h3>`;
                result += `<p>æˆåŠŸ: ${importResult.success}</p>`;
                
                if (importResult.success && importResult.data) {
                    result += `<p>æ€»æ•°: ${importResult.data.total}</p>`;
                    result += `<p>æˆåŠŸ: ${importResult.data.successCount}</p>`;
                    result += `<p>å¤±è´¥: ${importResult.data.errorCount}</p>`;
                    
                    if (importResult.data.errors && importResult.data.errors.length > 0) {
                        result += `<p>é”™è¯¯: ${importResult.data.errors.join(', ')}</p>`;
                    }
                } else {
                    result += `<p>é”™è¯¯: ${importResult.error}</p>`;
                }
                
                output.innerHTML += `<div class="bg-green-50 border border-green-200 rounded p-4 mt-4">${result}</div>`;
                
            } catch (error) {
                output.innerHTML += `<div class="bg-red-50 border border-red-200 rounded p-4 mt-4">
                    <p class="text-red-700">å¯¼å…¥æµ‹è¯•å¤±è´¥: ${error.message}</p>
                </div>`;
            }
        }
    </script>
</body>
</html>